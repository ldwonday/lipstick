export const roundRect = (ctx, x, y, w, h, r, fill) => {
  ctx.save();
  // 开始绘制
  ctx.beginPath();
  // 因为边缘描边存在锯齿，最好指定使用 transparent 填充
  // 这里是使用 fill 还是 stroke都可以，二选一即可
  ctx.setFillStyle(fill);
  // ctx.setStrokeStyle('transparent')
  // 左上角
  ctx.arc(x + r, y + r, r, Math.PI, Math.PI * 1.5);

  // border-top
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.lineTo(x + w, y + r);
  // 右上角
  ctx.arc(x + w - r, y + r, r, Math.PI * 1.5, Math.PI * 2);

  // border-right
  ctx.lineTo(x + w, y + h - r);
  ctx.lineTo(x + w - r, y + h);
  // 右下角
  ctx.arc(x + w - r, y + h - r, r, 0, Math.PI * 0.5);

  // border-bottom
  ctx.lineTo(x + r, y + h);
  ctx.lineTo(x, y + h - r);
  // 左下角
  ctx.arc(x + r, y + h - r, r, Math.PI * 0.5, Math.PI);

  // border-left
  ctx.lineTo(x, y + r);
  ctx.lineTo(x + r, y);

  // 这里是使用 fill 还是 stroke都可以，二选一即可，但是需要与上面对应
  ctx.fill();
  // ctx.stroke()
  ctx.closePath();
};

export const circleImg = (ctx, img, x, y, r, fill = '#fff', stroke = '#fff') => {
  ctx.save();
  ctx.beginPath();
  var d = 2 * r;
  var cx = x + r;
  var cy = y + r;
  ctx.arc(cx, cy, r, 0, 2 * Math.PI);
  ctx.setFillStyle(fill);
  ctx.fill();
  ctx.clip();
  ctx.drawImage(img, x, y, d, d);
  ctx.restore();
};